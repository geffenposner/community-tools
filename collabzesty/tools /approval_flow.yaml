tools:
  - name: request_access
    alias: request_access
    description: >-
      A tool to request access, generating an IAM policy based on a description
      and creating an approval request in SQLite and sending a webhook
      notification.
    type: python
    content: "import os\nimport sqlite3\nimport sys\nfrom datetime import datetime, timedelta\nimport requests\nfrom litellm import completion\nimport uuid\n\nUSER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')\nSLACK_CHANNEL_ID = os.getenv('SLACK_CHANNEL_ID')\nSLACK_THREAD_TS = os.getenv('SLACK_THREAD_TS')\nKUBIYA_USER_ORG = os.getenv('KUBIYA_USER_ORG')\nKUBIYA_API_KEY = os.getenv('KUBIYA_API_KEY')\nAPPROVAL_SLACK_CHANNEL = os.getenv('APPROVAL_SLACK_CHANNEL')\nOPENAI_API_KEY = os.getenv('OPENAI_API_KEY')\nOPENAI_API_BASE = os.getenv('OPENAI_API_BASE')\n\npurpose = \"{{.purpose}}\"\nttl = \"{{.ttl}}\"\npolicy_name = \"{{.policy_name}}\"\npermission_set_name = \"{{.permission_set_name}}\"\npolicy_description = \"{{.policy_description}}\"\n\ndef generate_policy(policy_description: str) -> str:\n    print(\"✨ Generating least privileged policy JSON...\")\n    messages = [{\"content\": f\"Generate a least privileged policy JSON for the following description: {policy_description} - return the JSON object.\",\n     \"role\": \"user\"}]\n    try:\n        response = completion(model=\"gpt-4o\", messages=messages)\n        if not response['choices']:\n            print(\"❌ Error: No response from OpenAI API. Could not generate policy.\")\n            sys.exit(1)\n        content = response['choices'][0]['message']['content']\n        start = content.find('{')\n        end = content.rfind('}')\n        return content[start:end+1]\n    except Exception as e:\n        print(f\"❌ Policy generation failed: {e}\")\n        sys.exit(1)\n\npolicy_json = generate_policy(policy_description)\nprint(f\"✅ Generated least privileged policy JSON:\\n\\n{policy_json}\")\n\ntry:\n    if ttl[-1] == 'm':\n        ttl_minutes = int(ttl[:-1])\n    elif ttl[-1] == 'h':\n        ttl_minutes = int(ttl[:-1]) * 60\n    elif ttl[-1] == 'd':\n        ttl_minutes = int(ttl[:-1]) * 60 * 24\n    else:\n        print(\"❌ Error: Unsupported TTL format. Use 'm', 'h', or 'd'. Defaulting to 30 days.\")\n        ttl_minutes = 30 * 24 * 60\nexcept ValueError:\n    print(\"❌ Error: Invalid TTL format. Defaulting to 30 days.\")\n    ttl_minutes = 30 * 24 * 60\n\nrequest_id = str(uuid.uuid4())\n\nprint(\"\U0001F4DD Creating approval request...\")\n\napproval_request = {\n    'user_email': USER_EMAIL,\n    'purpose': purpose,\n    'ttl_minutes': ttl_minutes,\n    'policy_name': policy_name,\n    'permission_set_name': permission_set_name,\n    'policy_json': policy_json,\n    'requested_at': datetime.utcnow().isoformat(),\n    'expires_at': (datetime.utcnow() + timedelta(minutes=ttl_minutes)).isoformat(),\n    'slack_channel_id': SLACK_CHANNEL_ID,\n    'slack_thread_ts': SLACK_THREAD_TS,\n    'approved': 'pending',\n    'request_id': request_id\n}\n\nconn = sqlite3.connect('/sqlite_data/approval_requests.db')\nc = conn.cursor()\ntry:\n    c.execute('''ALTER TABLE approvals ADD COLUMN request_id text''')\nexcept sqlite3.OperationalError:\n    pass\n\nc.execute('''CREATE TABLE IF NOT EXISTS approvals\n             (user_email text, purpose text, ttl_minutes int, policy_name text, permission_set_name text, policy_json text, requested_at text, expires_at text, slack_channel_id text, slack_thread_ts text, approved text, request_id text)''')\n\nc.execute(\"INSERT INTO approvals (user_email, purpose, ttl_minutes, policy_name, permission_set_name, policy_json, requested_at, expires_at, slack_channel_id, slack_thread_ts, approved, request_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\",\n          (approval_request['user_email'], approval_request['purpose'], \n           approval_request['ttl_minutes'], approval_request['policy_name'], approval_request['permission_set_name'], \n           approval_request['policy_json'], approval_request['requested_at'], approval_request['expires_at'], \n           approval_request['slack_channel_id'], approval_request['slack_thread_ts'], 'pending', approval_request['request_id']))\nconn.commit()\nprint(\"✅ Approval request created successfully.\")\n\n# Cleanup old requests\nexpiry_threshold = datetime.utcnow() - timedelta(days=30)\nc.execute(\"DELETE FROM approvals WHERE expires_at < ?\", (expiry_threshold.isoformat(),))\nconn.commit()\nprint(\"\U0001F9F9 Cleaned up old, expired approval requests.\")\n\nconn.close()\n\nentry = {\n    \"user_email\": USER_EMAIL,\n    \"purpose\": purpose,\n    \"ttl_minutes\": ttl,\n    \"policy_name\": policy_name,\n    \"permission_set_name\": permission_set_name,\n    \"policy_json\": policy_json,\n    \"request_id\": request_id\n}\n\n# Create and send webhook\nprompt = f\"You are an access management assistant. You are currently conversing with an approving group. Your task is to help the approving group decide whether to approve the following access request. You have a new access request from {USER_EMAIL} for the following purpose: {purpose}. The request will expire in {ttl}. The ID of the request is {request_id}. The policy to be created is: ```{policy_json}```\\n\\nCAREFULLY ASK IF YOU CAN MOVE FORWARD WITH THIS REQUEST. DO NOT EXECUTE THE REQUEST UNTIL YOU HAVE RECEIVED APPROVAL FROM THE USER YOU ARE ASSISTING.\"\n\npayload = {\n    \"agent_id\": os.getenv('KUBIYA_AGENT_UUID'),\n    \"communication\": {\n        \"destination\": APPROVAL_SLACK_CHANNEL,\n        \"method\": \"Slack\"\n    },\n    \"created_at\": datetime.utcnow().isoformat() + \"Z\",\n    \"created_by\": USER_EMAIL,\n    \"name\": \"Approval Request\",\n    \"org\": KUBIYA_USER_ORG,\n    \"prompt\": prompt,\n    \"source\": \"Triggered by an access request (Agent)\",\n    \"updated_at\": datetime.utcnow().isoformat() + \"Z\"\n}\n\nresponse = requests.post(\n    \"https://api.kubiya.ai/api/v1/event\",\n    headers={\n        'Content-Type': 'application/json',\n        'Authorization': f'UserKey {KUBIYA_API_KEY}'\n    },\n    json=payload\n)\n\nif response.status_code < 300:\n    print(f\"✅ WAITING: Request submitted successfully and has been sent to an approver. Waiting for approval.\")\n    event_response = response.json()\n    webhook_url = event_response.get(\"webhook_url\")\n    if webhook_url:\n        requests.post(\n            webhook_url,\n            headers={'Content-Type': 'application/json'},\n            json=payload\n        )\n    else:\n        print(\"❌ Error: No webhook URL returned in the response. Could not send webhook to approving channel.\")\nelse:\n    print(f\"❌ Error: {response.status_code} - {response.text}\")\n"
    args:
      purpose:
        description: The purpose of the request
        required: true
      ttl:
        description: >-
          Time to live for the request (format: 1m, 1h, 1d - only minutes (m),
          hours (h), and days (d) are supported)
        required: true
      policy_name:
        description: The name of the customer managed policy to create
        required: true
      permission_set_name:
        description: The name of the permission set to update
        required: true
      policy_description:
        description: >-
          A NATURAL LANGUAGE description of the policy to generate - this will
          be used to generate the policy JSON - should be a precise description
          of the permissions required, eg: 'Allow the user to read from the S3
          bucket named 'my-bucket' and write to the DynamoDB table named
          'my-table'.'
        required: true
    dependencies: |
      litellm
      requests
    env:
      - KUBIYA_USER_EMAIL
      - SLACK_CHANNEL_ID
      - SLACK_THREAD_TS
      - KUBIYA_AGENT_UUID
      - KUBIYA_USER_ORG
      - KUBIYA_API_KEY
      - APPROVAL_SLACK_CHANNEL
      - AWS_PROFILE
      - OPENAI_API_KEY
      - OPENAI_API_BASE
    with_volumes:
      - name: sqlite_data
        path: /sqlite_data
  - name: approve_request
    alias: approve_request
    description: >-
      Allows admins to approve or reject access requests - upon approval, a task
      is scheduled to delete the permission set after the TTL
    type: python
    content: "import os\nimport sqlite3\nimport sys\nfrom datetime import datetime, timedelta\nimport requests\nfrom pytimeparse.timeparse import timeparse\n\nAPPROVER_USER_EMAIL = os.getenv('KUBIYA_USER_EMAIL')\nAPPROVAL_SLACK_CHANNEL = os.getenv('APPROVAL_SLACK_CHANNEL')\nAPPROVING_USERS = os.getenv('APPROVING_USERS', '').split(',')\nSLACK_API_TOKEN = os.getenv('SLACK_API_TOKEN')\nKUBIYA_API_KEY = os.getenv('KUBIYA_API_KEY')\n\nif not APPROVER_USER_EMAIL:\n    print(\"❌ Missing APPROVER_USER_EMAIL environment variable\")\n    sys.exit(1)\n\nif \"{{.approval_action}}\" not in ['approved', 'rejected']:\n    print(\"❌ Error: Invalid approval action. Use 'approved' or 'rejected'.\")\n    sys.exit(1)\n\nif APPROVER_USER_EMAIL not in APPROVING_USERS:\n    print(f\"❌ User {APPROVER_USER_EMAIL} is not authorized to approve this request\")\n    sys.exit(1)\n\nrequest_id = \"{{.request_id}}\"\napproval_action = \"{{.approval_action}}\"\n\nconn = sqlite3.connect('/sqlite_data/approval_requests.db')\nc = conn.cursor()\n\n# Remove expired requests\nc.execute(\"DELETE FROM approvals WHERE expires_at < ?\", (datetime.utcnow().isoformat(),))\nconn.commit()\n\nc.execute(\"SELECT * FROM approvals WHERE request_id=? AND approved='pending'\", (request_id,))\napproval_request = c.fetchone()\n\nif not approval_request:\n    print(f\"❌ No pending approval request found for request ID {request_id}\")\n    sys.exit(1)\n\nc.execute(\"UPDATE approvals SET approved=? WHERE request_id=?\", (approval_action, request_id))\nconn.commit()\nconn.close()\n\nprint(f\"✅ Approval request with ID {request_id} has been {approval_action}\")\n\nif approval_action == \"approved\":\n    duration_minutes = approval_request[2]\n    duration_seconds = duration_minutes * 60\n\n    end_time = datetime.fromisoformat(approval_request[7])\n    \n    task_payload = {\n        \"execution_delay\": duration_seconds,\n        # TODO:: Notify both ends on Slack (easy to do with a dedicated Slack tool)\n        \"task_description\": f\"Immediately remove policy {approval_request[3]} from permission set {approval_request[4]} as the TTL has expired\",\n        \"channel_id\": APPROVAL_SLACK_CHANNEL,\n        \"user_email\": approval_request[0],\n        \"organization_name\": os.getenv(\"KUBIYA_USER_ORG\"),\n        \"agent\": os.getenv(\"KUBIYA_AGENT_PROFILE\")\n    }\n    response = requests.post(\n        'https://api.kubiya.ai/api/v1/scheduled_tasks',\n        headers={\n            'Authorization': f'UserKey {KUBIYA_API_KEY}',\n            'Content-Type': 'application/json'\n        },\n        json=task_payload\n    )\n\n    if response.status_code < 300:\n        print(f\"✅ Scheduled task to remove policy {approval_request[3]} from permission set {approval_request[4]} in {duration_minutes} minutes (expires at {end_time})\")\n    else:\n        print(f\"❌ Error: {response.status_code} - {response.text}\")\n\nslack_channel_id = approval_request[8]\nslack_thread_ts = approval_request[9]\n\n# Get permalink\npermalink_response = requests.get(\n    \"https://slack.com/api/chat.getPermalink\",\n    params={\n        'channel': slack_channel_id,\n        'message_ts': slack_thread_ts\n    },\n    headers={\n        'Authorization': f'Bearer {SLACK_API_TOKEN}'\n    }\n)\npermalink = permalink_response.json().get(\"permalink\")\n\naction_emoji = \":white_check_mark:\" if approval_action == \"approved\" else \":x:\"\naction_text = \"approved\" if approval_action == \"approved\" else \"rejected\"\napprover_text = f\"<@{APPROVER_USER_EMAIL}> {action_text} this request {action_emoji}\"\n\nslack_payload_main_thread = {\n    \"channel\": slack_channel_id,\n    \"text\": f\"<@{approval_request[0]}>, your request has been {approval_action}.\",\n    \"blocks\": [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": f\"*Request {approval_action}* {action_emoji}\\n*Reason:* {approval_request[1]}\\n*Access:* {approval_request[3]} for {approval_request[2]}\\n*Status:* {approver_text}\\n<{permalink}|View original conversation>\"\n            }\n        },\n        {\n            \"type\": \"actions\",\n            \"elements\": [\n                {\n                    \"type\": \"button\",\n                    \"text\": {\n                        \"type\": \"plain_text\",\n                        \"text\": \"↗️\U0001F4AC View Thread\"\n                    },\n                    \"url\": permalink\n                }\n            ]\n        }\n    ],\n}\n\nslack_payload_in_thread = {\n    \"channel\": slack_channel_id,\n    \"text\": f\"<@{approval_request[0]}>, your request has been {approval_action}.\",\n    \"thread_ts\": slack_thread_ts,\n    \"blocks\": [\n        {\n            \"type\": \"section\",\n            \"text\": {\n                \"type\": \"mrkdwn\",\n                \"text\": f\"Good news! {approver_text} :tada:\\n\\nYou can now proceed with your request. Go ahead and try your brand new permissions! :rocket:\\n\\nNote: This permission will be removed automatically after {approval_request[2]} by the system.\"\n            }\n        }\n    ]\n}\n\nfor slack_payload in [slack_payload_main_thread, slack_payload_in_thread]:\n  slack_response = requests.post(\n      \"https://slack.com/api/chat.postMessage\",\n      headers={\n          'Content-Type': 'application/json',\n          'Authorization': f'Bearer {SLACK_API_TOKEN}'\n      },\n      json=slack_payload\n  )\n\n  if slack_response.status_code < 300:\n      print(f\"✅ All done! Slack notification sent successfully. Response: {slack_response.text}\")\n  else:\n      print(f\"❌ Error sending Slack notification: {slack_response.status_code} - {slack_response.text}\")\n"
    args:
      request_id:
        description: The unique identifier for the request being approved or rejected
        required: true
      approval_action:
        description: Approval action (approved or rejected)
        required: true
    env:
      - KUBIYA_USER_EMAIL
      - APPROVING_USERS
      - APPROVAL_SLACK_CHANNEL
      - SLACK_API_TOKEN
      - KUBIYA_API_KEY
      - KUBIYA_USER_ORG
      - KUBIYA_AGENT_PROFILE
    dependencies: |
      requests
      pytimeparse==1.1.8
    with_volumes:
      - name: sqlite_data
        path: /sqlite_data
